<!-- EDISON:START -->
<!-- GENERATED BY EDISON - DO NOT EDIT -->
<!-- Source: core + pack(happy-stacks) + pack(expo) + pack(typescript) + pack(react) + pack(prisma) + pack(e2e-web) -->
<!-- Regenerate: edison compose all -->

# Edison Framework

## MANDATORY: Constitution

**This is a MANDATORY READ.** You MUST read your role-specific constitution file FIRST before any work.

### Re-Read Requirements

**You MUST re-read your constitution:**
- At the START of every new session
- After ANY context compaction
- Whenever you notice the constitution is no longer in your context
- When instructed by the user

### Constitution Locations

| Your Role | Constitution File |
|-----------|-------------------|
| Orchestrator | `edison read ORCHESTRATOR --type constitutions` |
| Agent (Implementer) | `edison read AGENTS --type constitutions` |
| Validator | `edison read VALIDATORS --type constitutions` |

**Determine your role from the task assignment, then read the appropriate constitution.**

## Role Determination

- **Orchestrator**: You are coordinating work, delegating tasks, managing sessions
- **Agent**: You are implementing features, writing code, fixing bugs
- **Validator**: You are reviewing code, validating changes, running checks

---

**DO NOT PROCEED WITHOUT READING YOUR CONSTITUTION FIRST.**
<!-- EDISON:END -->

# Agent / Contributor Guide (happy-stacks)

It is designed for:

- running the **Happy** stack fully on your own machine (server + UI + CLI/daemon)
- securely accessing it remotely (recommended: **Tailscale Serve** for HTTPS secure context)
- developing on Happy across multiple repos using **worktrees**
- running multiple isolated instances via **stacks**
- maintaining a **patched fork** while still producing **clean upstream PRs**

If you are an LLM agent: treat this file as the “ground truth” for workflows, naming, and commands.

---

### Big picture (what lives where)

#### **This repo**

- `scripts/*.mjs`: orchestration CLIs (bootstrapping, run/dev/build, worktrees, stacks, service, tailscale).
- `components/*`: cloned component repos (each is its own Git repo).
- `components/.worktrees/*`: all worktrees (keeps `components/*` “clean”).

#### **Happy components**

The main components managed by happy-stacks:

- `happy` (UI)
- `happy-cli` (CLI + daemon)
- `happy-server-light` (lightweight server)
- `happy-server` (full server)

---

### Critical invariants / expectations

#### **Stay upstream-compatible**

- Your changes in our forks should stay compatible with upstream (`slopus/*`).
- Avoid “fork-only hacks” that permanently diverge unless explicitly intended.
- Prefer feature flags, clean commits, and PR-ready changes.

---

### Non-negotiables for agents (read this first)

These rules are strict on purpose. They exist so we can iterate quickly, test safely, and produce clean PRs for both `slopus/*` (upstream) and `leeroybrun/*` (our forks).

#### **Command discipline (CRITICAL: only use `happys ...`)**

**If you are an LLM agent:** you must treat `happys` as the *only* supported entrypoint for running anything. Happy Stacks relies on stack-scoped env, isolation, and managed infra; bypassing it causes “half-stacks”, cross-stack interference, and hard-to-debug auth/machine issues.

- **Allowed (use these)**
  - `happys start` / `happys dev`
  - `happys typecheck [component...]` (stack-aware typechecks)
  - `happys stack new <name>` (creates stack env + isolated dirs; copies auth from `main` by default)
  - `happys stack start <name>` / `happys stack dev <name>` / `happys stack doctor <name>`
  - `happys stack typecheck <name> [component...]` (typecheck under a stack env file)
  - `happys srv use ...` / `happys stack srv <name> -- use ...`
  - `happys wt ...` / `happys stack wt <name> -- ...`
  - `happys tailscale ...` / `happys stack tailscale:... <name>`
  - `happys service ...` / `happys stack service <name> ...`

- **Forbidden (do NOT run these directly)**
  - **Expo/UI**: `expo ...`, `pnpm dev`, `yarn dev`, `npm run dev` inside `components/happy`
  - **Servers**: `yarn dev/start` inside `components/happy-server*`, running Fastify/Vite/Next/etc directly
  - **Infra**: `docker compose ...` or `docker ...` to start Postgres/Redis/Minio manually for stacks
  - **Worktrees**: raw `git worktree ...` (use `happys wt ...`)
  - **“One-off” partial actions**: starting only the daemon, only the server, or only the UI without `happys` wrappers

If you’re tempted to run a low-level command, stop and route it through `happys` (or add a `happys` subcommand if missing).

---

### Code validation (typecheck + lint + build + test)

**When you change code, you must validate using `happys` commands (not raw `yarn`, `pnpm`, `expo`, or `tsc`).**

- **Typecheck (active checkouts)**:
  - `happys typecheck`
  - `happys typecheck happy`
  - `happys typecheck happy happy-cli`

- **Typecheck (stack-scoped)**:
  - `happys stack typecheck <stack> [component...]`

- **Lint (active checkouts)**:
  - `happys lint`
  - `happys lint happy`

- **Lint (stack-scoped)**:
  - `happys stack lint <stack> [component...]`

- **Build the web UI bundle** (what server-light serves):
  - `happys build`
  - (stack-scoped) `happys stack build <stack>`

- **Tests (active checkouts)**:
  - `happys test`
  - `happys test happy`

- **Tests (stack-scoped)**:
  - `happys stack test <stack> [component...]`

#### **Edison evidence capture (recommended)**

When working with Edison tasks/QA, capture trusted evidence via:

- `happys edison --stack=<stack> -- evidence capture <task-id>`
- Or omit `--stack` and let `happys edison` infer it from task/QA frontmatter:
  - `happys edison -- evidence capture <task-id>`
  - (Works for both global tasks under `.project/tasks/**` and session tasks under `.project/sessions/**`.)

Quick “slash command” reads (Happy-local Edison):

- Plan a feature + create the right task graph: `happys edison -- read START_PLAN_FEATURE --type start`
- Validate a task correctly (stack-scoped): `happys edison -- read START_VALIDATE_TASK --type start`
- Start a new happy-local session (no Edison worktrees): `happys edison -- read START_HAPPY_STACKS_NEW_SESSION --type start`

Notes:
- `happys typecheck` runs against the **active checkout** for each component (it respects any `HAPPY_STACKS_COMPONENT_DIR_*` overrides set via `happys wt use ...` or `happys stack wt ...`).
- It does **not** currently typecheck *every* worktree automatically; to typecheck a specific worktree, switch it active first (via `happys wt use ...` / `happys stack wt ...`) then run `happys typecheck <component>`.

#### **Worktree targeting (stack + one-shot)**

If you want to validate a specific worktree **without** changing the stack’s env permanently, you can pass one-shot component overrides:

- `happys stack typecheck <stack> --happy=<owner/branch|/abs/path> [component...]`
- `happys stack build <stack> --happy=<owner/branch|/abs/path>`

Examples:

- `happys stack typecheck exp1 --happy=slopus/pr/my-branch happy`
- `happys stack build exp1 --happy=/absolute/path/to/checkout`

---

### Main stack safety (do not repoint by accident)

The default stack (`main`) is meant to stay stable. By default, **`happys wt use` refuses to repoint main’s component directories to a worktree/path** and will instruct you to use a new stack instead.

- **Recommended**: create a new stack and switch that stack’s components:
  - `happys stack new exp1 --interactive`
  - `happys stack wt exp1 -- use happy slopus/pr/my-branch`

- **Override** (only if you really mean it): pass `--force`:
  - `happys wt use happy slopus/pr/my-branch --force`

---

### Safety invariants (must not regress)

These are intentional safety properties of Happy Stacks. If you change code under `scripts/`, preserve these invariants (or explicitly redesign them with the user).

#### **Process isolation (stacks)**

- **Never kill by port in stack mode**: stack-scoped commands must not “kill whatever is listening on a port”.
  - Stack stop/restart must kill only processes that can be **proven owned** by the stack (via env-file / stack markers, CLI home dir, and/or `stack.runtime.json` recorded PIDs).
  - Port-based killing (e.g. `killPortListeners`) is allowed only in **non-stack** local convenience paths.

#### **Ephemeral ports (non-main stacks)**

- **Ephemeral stacks pick ports at start time**: non-main stacks do not pin ports in their env files; ports are chosen on stack start and recorded in `stack.runtime.json`.
- **Restart reuses ports (or fails closed)**: `happys stack dev/start <stack> --restart` must reuse the previous runtime ports when available.
  - If any reused port is unexpectedly occupied, the command must **error** (fail-closed) rather than killing unknown listeners or silently reallocating ports (which would break component communication).
  - To allocate new ports intentionally, stop the stack and re-run without `--restart`.

#### **Watch mode**

- **Watcher restarts must be stack-owned**: watcher-driven restarts (server/daemon/UI) must only restart processes if the PID is known and provably stack-owned.
  - If the PID is unknown (e.g. server was already running), watchers should refuse and instruct to re-run with `--restart` so Happy Stacks can spawn + track PIDs.

#### **Tailscale Serve (public URLs)**

- **Do not auto-enable or repoint Tailscale Serve for non-main stacks by default**.
  - Non-main stacks should default to `http://localhost:<port>` unless the user explicitly configured a public URL.
  - Expo web dev UI should default to the stack’s local server URL (not a shared `*.ts.net` URL).

#### **Daemons**

- **Multiple daemons are expected**: one per stack is normal. Never “fix” issues by killing all daemons.
- **Daemon kills must be ownership-gated**: any fallback kill path (lockfile/state PID) must verify the process is tied to the correct stack home dir (`HAPPY_HOME_DIR`) and refuse otherwise.

---

### Multi-stack daemons (expected behavior)

Each stack is isolated (ports + CLI home dir). That means **running multiple stacks can legitimately result in multiple daemons** (one per stack).

- **Do NOT “fix” issues by killing all daemons**. That will break other stacks.
- **Diagnose per stack**:
  - `happys stack doctor <stack>`
  - `happys stack auth <stack> status`
- **Start/stop per stack**:
  - `happys stack dev <stack>` (dev, includes UI by default)
  - `happys stack start <stack>` (prod-like)
  - If you need to start a stack without a daemon (rare): `happys stack dev <stack> -- --no-daemon`

#### **Env templates (safe for agents)**

- **Preferred**: edit `.env.example` (canonical template).
- **If blocked**: if your tool refuses to read/edit `.env.example` due to safety restrictions, **do not create/edit an `env.example` workaround**. Instead, tell the user what to change and ask them to apply it manually.
- **Do not read/edit**: `.env`, `env.local`, or any `.env.*.local` files (these may contain secrets and are intentionally ignored by LLM tooling).

#### **You must develop in worktrees only**

- **Do not develop directly inside `components/<component>`** (the default checkouts under this repo).
  - Treat `components/<component>` as **read-only** “launcher defaults”.
  - **Never create feature branches or commits** on those default checkouts, especially not on `main`.
- **All changes must happen inside `components/.worktrees/<component>/...`** created/managed by `happys wt ...`.
- **Do not use raw `git worktree`**. Use `happys wt` tooling so the repo stays consistent.

#### **You must test changes inside isolated stacks**

- When testing a feature/PR, use an isolated stack (or a dedicated “exp” stack).
- Point the stack at your worktrees using `happys stack wt <stack> -- use ...`.
- Avoid editing `env.local` by hand; prefer stack-scoped env via the stack env file.

#### **Auth + secrets (stacks)**

- **Auth seeding (stacks)**: non-main stacks can be auto-seeded from a **configured seed stack** (recommended: `dev-auth`) so they typically **do not require re-login**.
  - Configure via `HAPPY_STACKS_AUTH_SEED_FROM=<seed>` and `HAPPY_STACKS_AUTO_AUTH_SEED=1`.
  - **Agents should not create seed stacks or dev keys**; they should only consume existing seeds (e.g. `copy-from dev-auth`) and use `happys auth dev-key --print` for UI login when needed.
- **Opt out**: pass **`--no-copy-auth`** (or `--fresh-auth`) to force a fresh login / new machine identity.
- **If you already have a stack and it’s missing auth** (common when it was created with `--no-copy-auth`, created before this behavior existed, or its `cli/` dir was cleaned):
  - Copy from your seed stack (no re-login, non-interactive): `happys stack auth <name> copy-from <seed>` (recommended: `dev-auth`)
  - Note: this copies **CLI credentials + master secret** and will also **seed the target DB** by copying **Account rows** from the seed stack into the target stack DB. This avoids FK errors like Prisma `P2003` without copying large DB files.
  - If you don't know the seed stack, fall back to: `happys stack auth <name> copy-from main`
- **If auth is required**:
  - main: `happys auth login`
  - stack: `happys stack auth <name> login`

#### **Upstream PRs must remain clean**

- If it should go to `slopus/*`, the branch must be based on `upstream/main` (or the upstream base branch) and contain **only** the upstream-worthy commits.
- **Upstream-first policy**: start implementation work on an **upstream-based** worktree/branch.
  - After the feature is complete, **validate it against our fork** by doing a **test-merge in a temporary fork branch/worktree**.
  - If the test-merge is clean: open a PR to the `leeroybrun/*` fork from that temp branch.
  - If it conflicts: create a dedicated fork PR branch/worktree (based on the fork’s target branch) and **cherry-pick** the upstream commits, resolving conflicts there.

#### **Commit messages (Conventional Commits)**

Use the **Conventional Commits** spec for all commits (and for the final **squash** commit message when squashing). This is the most widely adopted modern standard for readable history and tooling like changelogs/release automation.

Spec: [Conventional Commits v1.0.0](https://www.conventionalcommits.org/en/v1.0.0/)

Format:

```text
<type>[optional scope][!]: <description>

[optional body]

[optional footer(s)]
```

- **type**: one of `feat`, `fix`, `docs`, `refactor`, `test`, `chore`, `build`, `ci`, `perf`, `revert`
- **scope (optional)**: short, lowercase area name (examples: `scripts`, `wt`, `stack`, `srv`, `env`, `docs`)
- **description**: imperative mood, present tense, no trailing period (example: “add”, “fix”, “remove”)
- **breaking changes**: add `!` (preferred) and/or a footer `BREAKING CHANGE: ...`
- **issue references (optional)**: add in footers (example: `Refs #123`, `Closes #123`)

Examples:

```text
feat(wt): add --stash option to update-all
fix(ports): avoid collisions when multiple stacks start
docs(agents): document Conventional Commits
refactor(stack): split env loading into helpers
```

#### **Document fork additions**

When you add a feature/fix/infra change in any fork under `components/*`:

- Update that component’s **README** (top “Fork additions” section).
- Include a short bullet describing the change.
- If there’s an upstream PR (opened or merged), include an inline link to it (e.g. `slopus/<repo>#123`).
  - If it’s not upstreamed yet, link to the fork PR/branch instead.

#### **Our fork’s `main` is a “distribution” branch**

We maintain fork-specific changes so people can use our fork directly.

- Treat fork `main` (and default `components/<component>` checkouts) as **read-only**.
- Never develop directly on fork `main`. Use worktrees/branches and PRs.

#### **Upstream PRs must be clean**

When contributing back to upstream:

- base PR branches on upstream `main` (or the appropriate upstream base)
- do not include fork-only patches in upstream PR branches

The tooling below exists so you don’t have to manually re-copy changes between branches.

---

### Git remotes + naming conventions

#### **Remotes**

Each component repo under `components/<component>` should typically have:

- `upstream`: upstream repo (often `slopus/*`)
- `origin` (or `fork`): our fork (often `leeroybrun/*`)
  - Some component checkouts (notably `happy-server` / `happy-server-light`) use the Git remote name `fork` instead of `origin`.
  - `happys wt ...` treats `origin` and `fork` as interchangeable; raw `git ...` commands should use whichever remote name exists in that repo (`git remote -v`).

#### **Branch naming**

Branches created/managed by worktree tooling are owner-prefixed:

```
<owner>/<branch...>
```

Examples:

- `leeroybrun/local/my-patch` (fork-only)
- `slopus/pr/123-fix-thing` (upstream PR branch)

---

### Worktrees (how we do parallel PR work safely)

#### **Layout**

All worktrees live under:

```
components/.worktrees/<component>/<owner>/<branch...>
```

Examples:

- `components/.worktrees/happy/slopus/pr/123-fix-thing`
- `components/.worktrees/happy-cli/leeroybrun/local/my-patch`

#### **Active component selection**

Happy-stacks runs components from `components/<component>` by default.
You can override per component via env vars (prefer `HAPPY_STACKS_*`):

- `HAPPY_STACKS_COMPONENT_DIR_HAPPY`
- `HAPPY_STACKS_COMPONENT_DIR_HAPPY_CLI`
- `HAPPY_STACKS_COMPONENT_DIR_HAPPY_SERVER_LIGHT`
- `HAPPY_STACKS_COMPONENT_DIR_HAPPY_SERVER`

Legacy aliases still work:

- `HAPPY_LOCAL_COMPONENT_DIR_*`

Use `happys wt use ...` instead of editing env files by hand. (Legacy in a cloned repo: `pnpm wt use ...`.)

---

### One worktree vs two worktrees (slopus vs leeroybrun divergence)

We often want the *same* change on both upstream and our fork, but sometimes our forks have diverged enough that we need separate implementations.

#### **Default: start with one worktree**

Use **one** worktree when:

- the change is intended to be upstreamed eventually, and
- the diff can apply cleanly to both upstream and our fork (or needs only small, mechanical adjustments).

In this case, develop in an **upstream-based** worktree (clean history). Once it’s complete:

- **Upstream PR**: open a PR to `slopus/*`.
- **Fork PR**: do a **test-merge in a temporary fork branch/worktree**; if it’s clean, open a PR to `leeroybrun/*`. If it conflicts, fall back to a fork PR branch with cherry-picks (see workflows below).

#### **Use two worktrees when needed**

Use **two** worktrees when:

- upstream (`slopus/*`) and our fork (`leeroybrun/*`) need materially different behavior, OR
- our fork has extra features/patches that require a fork-only variant, OR
- upstream is moving slowly and we need a fork-only patch now but still want a clean upstream PR later.

Pattern:

- **Upstream implementation worktree**: `--from=upstream` (clean, upstream-acceptable commits)
- **Fork integration worktree**: based on the fork’s target branch (often `origin/main`), used to test-merge / cherry-pick and carry any fork-only adaptations

Keep them in sync by **cherry-picking** shared commits from the upstream branch into the fork branch, and then layering any fork-only changes on top in the fork integration worktree.

---

### Stacks (multiple isolated “instances”)

A “stack” is an isolated set of:

- server port
- UI build dir
- CLI home dir
- optional component directory overrides (pointing at worktrees)

#### **Storage layout**

New canonical storage root:

```
~/.happy/stacks/<name>/...
```

Stack env file:

```
~/.happy/stacks/<name>/env
```

Legacy stack env files are still supported:

```
~/.happy/local/stacks/<name>/env
```

To migrate legacy stack env files:

```bash
happys stack migrate
```

---

### Environment loading + precedence (important)

Scripts load environment in this order:

1. `~/.happy-stacks/.env` (lowest precedence; created by `happys init`)
2. `~/.happy-stacks/env.local`
3. stack env file (highest precedence) via `HAPPY_STACKS_ENV_FILE` (legacy: `HAPPY_LOCAL_ENV_FILE`)

Backwards compatible fallback for cloned-repo usage (when home config doesn’t exist yet):

1. repo `.env` (lowest precedence)
2. repo `env.local`
3. stack env file (highest precedence)

For a complete mental model of the different paths (CLI root vs home vs runtime vs workspace vs stack storage) and the exact env precedence, see: `[docs/paths-and-env.md](docs/paths-and-env.md)`.

#### **Prefix migration**

Canonical prefix: `HAPPY_STACKS_*`
Legacy prefix: `HAPPY_LOCAL_*`

The loader maps both ways so either prefix works, but new configuration should use `HAPPY_STACKS_*`.

---

### The only commands you should use (cheat sheet)

#### **Install / init (recommended)**

No repo clone required:

```bash
npx happy-stacks init
export PATH="$HOME/.happy-stacks/bin:$PATH"
```

Optional (automate PATH changes):

```bash
npx happy-stacks init --install-path
```

#### **Bootstrap / setup**

Clone missing components, install deps, build/link wrappers, optional autostart:

```bash
happys bootstrap
happys bootstrap --interactive
```

Pick upstream clone source explicitly:

```bash
happys bootstrap --forks
happys bootstrap --upstream
```

#### **Run**

Production-like (serves built UI via server-light):

```bash
happys start
```

Dev mode (Expo web dev server for UI):

```bash
happys dev
```

Notes (dev reliability):

- `happys dev` will **install deps as needed** and will **auto-build `happy-cli`** if its `dist/` output is missing or out of date.
- In interactive TTY runs, `happys dev` enables a lightweight watcher for `happy-cli` changes and will **rebuild + restart the daemon** as needed.
  - Disable: `happys dev --no-watch`
  - Force-enable: `happys dev --watch`
  - Build mode control: `HAPPY_STACKS_CLI_BUILD_MODE=auto|always|never` (legacy prefix also supported: `HAPPY_LOCAL_CLI_BUILD_MODE`)

#### **Server flavor**

We support `happy-server-light` and `happy-server` (not simultaneously for one run).

```bash
happys srv status
happys srv use happy-server-light
happys srv use happy-server
happys srv use --interactive
```

Note: in a cloned repo, `pnpm srv -- ...` still works (legacy).

#### **Worktrees**

Key commands:

```bash
happys wt migrate
happys wt use --interactive
happys wt new --interactive
happys wt list happy
happys wt status happy
happys wt sync-all
happys wt update-all --dry-run
happys wt update-all --stash
happys wt git happy active -- status
happys wt shell happy slopus/pr/123-fix-thing
happys wt code happy slopus/pr/123-fix-thing
happys wt cursor happy slopus/pr/123-fix-thing
```

Create a worktree for an upstream PR:

```bash
happys wt pr happy https://github.com/slopus/happy/pull/123 --use
```

Update a PR worktree when new commits are pushed:

- `--update` fast-forwards only
- if not possible, it aborts and tells you to use `--force`
- use `--stash` to auto-stash local modifications before updating

```bash
happys wt pr happy 123 --update
happys wt pr happy 123 --update --stash
happys wt pr happy 123 --update --force
```

#### **Stacks**

Create and run additional isolated stacks:

```bash
happys stack new exp1 --interactive
happys stack dev exp1
happys stack start exp1
happys stack edit exp1 --interactive
happys stack list
```

Run worktree tooling scoped to a stack env file:

```bash
happys stack wt exp1 -- use --interactive
happys stack wt exp1 -- status happy
```

Switch server flavor for a stack:

```bash
happys stack srv exp1 -- use --interactive
```

---

### Common workflows (copy/paste)

These are the most common flows we expect agents to follow. Prefer these over ad-hoc git worktree/env edits.

#### **1) Create a clean upstream PR worktree (based on `upstream/main`)**

Example: you want to propose a change to upstream `slopus/happy`.

```bash
# Create a new worktree branch based on upstream.
happys wt new happy pr/my-feature --from=upstream --use

# (optional) open a shell/editor in that worktree
happys wt shell happy active
happys wt cursor happy active

# When done, push to upstream remote (or push to your fork and open PR to upstream)
happys wt push happy active --remote=upstream
```

Notes:
- This worktree lives under `components/.worktrees/happy/slopus/pr/my-feature` (owner inferred from `upstream`).
- Keep this branch clean: **only** the upstream-worthy change(s).

#### **2) Validate and ship the change to our fork (test-merge → cherry-pick fallback)**

Example: you implemented a change on an upstream-based worktree and now want a clean PR to `leeroybrun/*` without developing on fork `main`.

```bash
# (recommended) ensure our mirror branches are up to date
happys wt sync-all

# Create a temporary fork integration worktree based on our fork target branch
happys wt new happy tmp/merge-pr-my-feature --from=origin --use

# Attempt a test-merge of the upstream branch into this fork branch
# (run git merge/cherry-pick inside the worktree; exact refs vary by repo setup)
happys wt git happy active -- merge --no-ff <upstream-branch-or-commit>

# If the merge is clean: push and open a PR to our fork
happys wt push happy active --remote=origin
```

If the test-merge conflicts:

- Abort the merge, then create a dedicated fork PR branch/worktree (based on the fork target branch).
- Cherry-pick the upstream commits onto it, resolve conflicts, then push and open the fork PR.

#### **2b) Fork-only change (still upstream-first by default)**

If a change is *not* intended for upstream, we still prefer starting from an upstream-based worktree so we don’t accidentally bake fork divergence into the implementation.

- Implement on an upstream-based worktree (but don’t open an upstream PR).
- Then use the workflow above (**test-merge → cherry-pick fallback**) to create the fork PR branch.

#### **3) Check out a GitHub PR as a worktree**

Example: you want to review/test a PR locally without mixing it into other work.

```bash
# Create from PR URL (recommended)
happys wt pr happy https://github.com/slopus/happy/pull/123 --use

# Update later when new commits land on the PR:
happys wt pr happy 123 --update

# If the worktree is dirty:
happys wt pr happy 123 --update --stash

# If the PR was force-pushed and FF-only fails:
happys wt pr happy 123 --update --force
```

#### **4) Switch what the launcher runs (“activate” a worktree)**

Example: you have multiple worktrees and want `happys dev/start/build` to use one of them.

```bash
happys wt use happy slopus/pr/123-fix-thing
happys wt use happy-cli default
happys wt use happy-server-light default
```

Reset back to defaults:

```bash
happys wt use happy default
happys wt use happy-cli default
happys wt use happy-server-light default
```

#### **5) Create a new stack (isolated env + ports + dirs)**

Interactive (recommended):

```bash
happys stack new exp1 --interactive
happys stack dev exp1
```

Non-interactive:

```bash
happys stack new exp2 --port=3010 --server=happy-server-light
happys stack start exp2
```

#### **6) Test a PR inside a stack (recommended for parallel work)**

Example: keep your “main” stack stable, test PRs in `exp1`.

```bash
# Create/update PR worktree
happys wt pr happy 123 --use

# Point exp1 at that worktree (stack-scoped; does NOT touch env.local)
happys stack wt exp1 -- use happy slopus/pr/123-fix-thing

# Run the stack
happys stack dev exp1
```

#### **6b) Test upstream vs fork variants side-by-side (two stacks)**

Example: compare behavior between an upstream-based worktree and a fork integration worktree without cross-contaminating env/ports.

```bash
# Stack A points at upstream worktree
happys stack new pr-upstream --interactive
happys stack wt pr-upstream -- use happy slopus/pr/my-feature

# Stack B points at fork worktree
happys stack new pr-fork --interactive
happys stack wt pr-fork -- use happy leeroybrun/tmp/merge-pr-my-feature

# Run independently
happys stack dev pr-upstream
happys stack dev pr-fork
```

#### **7) Update everything (sync mirror branches + update active worktrees)**

```bash
# Ensure slopus/main (mirror) is up to date across components
happys wt sync-all

# Preview updates across components
happys wt update-all --dry-run

# Apply updates (auto-stash if needed)
happys wt update-all --stash
```

---

### How to contribute upstream without breaking our fork

#### **Preferred workflow**

- **Always start from upstream**: do implementation work on an **upstream-based** worktree (`--from=upstream`), not on fork `main` and not in `components/<component>`.
- Keep upstream PR branches clean and upstream-acceptable.
- Once the change is complete, **validate it on our fork** using the **test-merge → cherry-pick fallback** workflow:
  - Create a temporary fork integration worktree (`--from=origin`)
  - Test-merge the upstream branch/commit(s)
  - If clean: push and open a PR to `leeroybrun/*`
  - If conflicts: create a dedicated fork PR worktree/branch and cherry-pick the upstream commits, resolving conflicts there

#### **When upstream merges a change you also carried locally**

Git reconciles changes based on content/patches, not commit IDs. If the same lines land upstream, your branch update typically becomes a fast-forward or a small/no-op merge/rebase. When it can’t cleanly reconcile (conflicts), use the worktree commands with `--stash` / `--force` to proceed intentionally.

---

### Special note: `happy-server` vs `happy-server-light`

Conceptually they are “two flavors of the same upstream server codebase”:

- **Upstream** lives under the `slopus/happy-server` repo.
- In happy-stacks we keep **two local components** so you can switch server flavor easily:
  - `components/happy-server` (full server)
  - `components/happy-server-light` (lightweight server)

#### **Fork topology (important)**

Both of our forks are branches of a single fork repo:

- **Fork repo**: `leeroybrun/happy-server-light`
- **`happy-server` fork “main”**: branch `happy-server`
- **`happy-server-light` fork “main”**: branch `happy-server-light`
- **Remote naming**: in these server repos, our fork remote is typically named `fork` (not `origin`).

So you should expect to open **two fork PRs** (or one PR per target branch) when a server change needs to land in both flavors.

#### **How to implement server changes**

- **If the change is the same for both `happy-server` and `happy-server-light`**:
  - Implement once on an **upstream-based** worktree/branch (from `slopus/happy-server` `upstream/main`) and open a PR to `slopus/happy-server`.
  - Then validate/ship to our fork by doing the **test-merge → cherry-pick fallback** flow **twice**:
    - once targeting fork branch `happy-server`
    - once targeting fork branch `happy-server-light`
  - Result: PR(s) to `leeroybrun/happy-server-light` that land the same commits into both branches.

- **If the change must differ between `happy-server` and `happy-server-light`**:
  - Implement the upstream-acceptable portion on an upstream-based worktree and open the upstream PR if applicable.
  - For the fork:
    - create a worktree/branch targeting fork branch **`happy-server`** and land the full-server variant
    - create a separate worktree/branch targeting fork branch **`happy-server-light`** and land the light-server variant
  - Keep shared commits shared (cherry-pick), and isolate flavor-specific behavior into separate commits per branch.

---

### Autostart (macOS LaunchAgent)

- Each stack can have its own LaunchAgent.
- New label base: `com.happy.stacks` (legacy: `com.happy.local`).
- The service persists only the stack env file path, so you can edit stack settings without reinstalling.

Commands:

```bash
happys service install
happys service status
happys service tail
happys stack service exp1 install
happys stack service exp1 status
```

---

### SwiftBar menu bar plugin (optional)

- Installer: `happys menubar install`
- It supports stacks and worktrees, and uses the same terminal/shell preferences as `happys wt shell`.

---

### Agent guidelines (LLM-specific)

- **Do not edit component repos in-place on `components/<component>` (the default checkouts).**
  - Treat them as read-only launcher defaults.
  - Create a worktree for **every** change, no matter how small.
- **Always pick a target upstream** (usually `slopus`) and keep PR branches clean.
- **Use `happys wt` / `happys stack` commands instead of raw `git worktree` / manual env edits** whenever possible.
- **Respect env precedence**: stack env file overrides everything; don’t “hardcode” paths in scripts.
- **Avoid breaking changes** to env vars/paths; preserve legacy behavior when possible

---

### Keeping happy-stacks up to date

Happy-stacks can run from a persistent runtime install under `~/.happy-stacks/runtime` (recommended for SwiftBar/services).

```bash
happys self status
happys self update
```

### Debug + uninstall

```bash
happys where
happys uninstall --yes
```
