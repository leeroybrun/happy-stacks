ci:
  commands:
    # IMPORTANT (Happy Stacks discipline):
    # - Evidence commands MUST run via `happys` (not raw pnpm/yarn/expo/tsc/docker).
    # - Evidence is expected to be stack-scoped (use `happys edison --stack=<name> ...`),
    #   which sets HAPPY_STACKS_STACK + HAPPY_STACKS_ENV_FILE for the commands below.
    # Task-frontmatter templating is supported (Edison fills {{stack}} / {{components_csv}} from the task file).
    # Fail-closed rules:
    # - If task has no stack, evidence capture must fail.
    # - If env stack is set (via happys edison --stack=...), it must match the task stack.
    # - If task declares components, pass them as positional args to stack-scoped commands.
    type-check: 'KIND="{{hs_kind}}"; if [ -z "$KIND" ] || [ "$KIND" = "parent" ]; then echo "Refusing evidence capture for hs_kind=parent. Run evidence on a track/component task."; exit 1; fi; TASK_STACK="{{stack}}"; TASK_STACK="${TASK_STACK%\"}"; TASK_STACK="${TASK_STACK#\"}"; ENV_STACK="${HAPPY_STACKS_STACK:?Run via: happys edison --stack=$TASK_STACK -- evidence capture <task-id>}"; if [ -z "$TASK_STACK" ]; then echo "Missing task stack (fill frontmatter: stack)"; exit 1; fi; if [ "$ENV_STACK" != "$TASK_STACK" ]; then echo "Stack mismatch: env=$ENV_STACK task=$TASK_STACK"; exit 1; fi; IFS="," read -r -a COMPS <<< "{{components_csv}}"; node ./bin/happys.mjs stack typecheck "$TASK_STACK" "${COMPS[@]}"'
    lint: 'KIND="{{hs_kind}}"; if [ -z "$KIND" ] || [ "$KIND" = "parent" ]; then echo "Refusing evidence capture for hs_kind=parent. Run evidence on a track/component task."; exit 1; fi; TASK_STACK="{{stack}}"; TASK_STACK="${TASK_STACK%\"}"; TASK_STACK="${TASK_STACK#\"}"; ENV_STACK="${HAPPY_STACKS_STACK:?Run via: happys edison --stack=$TASK_STACK -- evidence capture <task-id>}"; if [ -z "$TASK_STACK" ]; then echo "Missing task stack (fill frontmatter: stack)"; exit 1; fi; if [ "$ENV_STACK" != "$TASK_STACK" ]; then echo "Stack mismatch: env=$ENV_STACK task=$TASK_STACK"; exit 1; fi; IFS="," read -r -a COMPS <<< "{{components_csv}}"; node ./bin/happys.mjs stack lint "$TASK_STACK" "${COMPS[@]}"'
    build: 'KIND="{{hs_kind}}"; if [ -z "$KIND" ] || [ "$KIND" = "parent" ]; then echo "Refusing evidence capture for hs_kind=parent. Run evidence on a track/component task."; exit 1; fi; TASK_STACK="{{stack}}"; TASK_STACK="${TASK_STACK%\"}"; TASK_STACK="${TASK_STACK#\"}"; ENV_STACK="${HAPPY_STACKS_STACK:?Run via: happys edison --stack=$TASK_STACK -- evidence capture <task-id>}"; if [ -z "$TASK_STACK" ]; then echo "Missing task stack (fill frontmatter: stack)"; exit 1; fi; if [ "$ENV_STACK" != "$TASK_STACK" ]; then echo "Stack mismatch: env=$ENV_STACK task=$TASK_STACK"; exit 1; fi; OUT_DIR="$PWD/.edison/_tmp/ui-build/$TASK_STACK"; export HAPPY_LOCAL_UI_BUILD_DIR="$OUT_DIR"; COMPS_CSV="{{components_csv}}"; case ",$COMPS_CSV," in (*,happy,*) node ./bin/happys.mjs stack build "$TASK_STACK" ;; (*) node ./bin/happys.mjs stack build "$TASK_STACK" -- --no-ui ;; esac'
    test: 'KIND="{{hs_kind}}"; if [ -z "$KIND" ] || [ "$KIND" = "parent" ]; then echo "Refusing evidence capture for hs_kind=parent. Run evidence on a track/component task."; exit 1; fi; TASK_STACK="{{stack}}"; TASK_STACK="${TASK_STACK%\"}"; TASK_STACK="${TASK_STACK#\"}"; ENV_STACK="${HAPPY_STACKS_STACK:?Run via: happys edison --stack=$TASK_STACK -- evidence capture <task-id>}"; if [ -z "$TASK_STACK" ]; then echo "Missing task stack (fill frontmatter: stack)"; exit 1; fi; if [ "$ENV_STACK" != "$TASK_STACK" ]; then echo "Stack mismatch: env=$ENV_STACK task=$TASK_STACK"; exit 1; fi; IFS="," read -r -a COMPS <<< "{{components_csv}}"; node ./bin/happys.mjs stack test "$TASK_STACK" "${COMPS[@]}"'
    track-coherence: 'KIND="{{hs_kind}}"; if [ -z "$KIND" ] || [ "$KIND" = "parent" ]; then echo "Refusing evidence capture for hs_kind=parent. Run evidence on a track/component task."; exit 1; fi; TASK_STACK="{{stack}}"; TASK_STACK="${TASK_STACK%\"}"; TASK_STACK="${TASK_STACK#\"}"; ENV_STACK="${HAPPY_STACKS_STACK:?Run via: happys edison --stack=$TASK_STACK -- evidence capture <task-id>}"; if [ -z "$TASK_STACK" ]; then echo "Missing task stack (fill frontmatter: stack)"; exit 1; fi; if [ "$ENV_STACK" != "$TASK_STACK" ]; then echo "Stack mismatch: env=$ENV_STACK task=$TASK_STACK"; exit 1; fi; node ./bin/happys.mjs edison track:coherence "{{task_id}}" --source=upstream --targets=fork,integration --json --max-lines=80'
    task-diff: 'KIND="{{hs_kind}}"; if [ -z "$KIND" ] || [ "$KIND" = "parent" ]; then echo "Refusing evidence capture for hs_kind=parent. Run evidence on a track/component task."; exit 1; fi; TASK_STACK="{{stack}}"; TASK_STACK="${TASK_STACK%\"}"; TASK_STACK="${TASK_STACK#\"}"; ENV_STACK="${HAPPY_STACKS_STACK:?Run via: happys edison --stack=$TASK_STACK -- evidence capture <task-id>}"; if [ -z "$TASK_STACK" ]; then echo "Missing task stack (fill frontmatter: stack)"; exit 1; fi; if [ "$ENV_STACK" != "$TASK_STACK" ]; then echo "Stack mismatch: env=$ENV_STACK task=$TASK_STACK"; exit 1; fi; REMOTE_DEFAULT="${HAPPY_STACKS_STACK_REMOTE:-upstream}"; IFS="," read -r -a COMPS <<< "{{components_csv}}"; echo "=== task-diff ==="; echo "task: {{task_id}}"; echo "stack: $TASK_STACK"; echo "stackRemote: ${REMOTE_DEFAULT}"; echo ""; for comp in "${COMPS[@]}"; do comp="$(echo "$comp" | tr -d "[:space:]")"; [ -z "$comp" ] && continue; case "$comp" in happy) dir="$HAPPY_STACKS_COMPONENT_DIR_HAPPY" ;; happy-cli) dir="$HAPPY_STACKS_COMPONENT_DIR_HAPPY_CLI" ;; happy-server) dir="$HAPPY_STACKS_COMPONENT_DIR_HAPPY_SERVER" ;; happy-server-light) dir="$HAPPY_STACKS_COMPONENT_DIR_HAPPY_SERVER_LIGHT" ;; *) dir="" ;; esac; echo "============================================================================"; echo "component: $comp"; if [ -z "$dir" ]; then echo "ERROR: missing component dir env for $comp"; exit 1; fi; echo "dir: $dir"; remote="$REMOTE_DEFAULT"; if ! git -C "$dir" remote get-url "$remote" >/dev/null 2>&1; then if [ "$remote" = "origin" ] && git -C "$dir" remote get-url fork >/dev/null 2>&1; then remote="fork"; elif [ "$remote" = "fork" ] && git -C "$dir" remote get-url origin >/dev/null 2>&1; then remote="origin"; fi; fi; if ! git -C "$dir" remote get-url "$remote" >/dev/null 2>&1; then echo "ERROR: remote not found in $comp repo: $remote"; git -C "$dir" remote -v || true; exit 1; fi; headref="$(git -C "$dir" symbolic-ref -q "refs/remotes/$remote/HEAD" 2>/dev/null || true)"; if [ -n "$headref" ]; then defaultBranch="${headref##*/}"; else defaultBranch="$(git -C "$dir" remote show "$remote" 2>/dev/null | sed -n "s/^  HEAD branch: //p" | head -1)"; fi; if [ -z "$defaultBranch" ]; then defaultBranch="main"; fi; if ! git -C "$dir" show-ref --quiet "refs/remotes/$remote/$defaultBranch"; then echo "ERROR: cannot resolve base ref refs/remotes/$remote/$defaultBranch"; echo "Hint: ensure $remote has a HEAD/default branch configured."; exit 1; fi; baseRef="$remote/$defaultBranch"; echo "baseRef: $baseRef"; echo ""; echo "--- status (porcelain) ---"; git -C "$dir" status --porcelain=v1 || true; echo ""; echo "--- commits on branch (baseRef..HEAD) ---"; git -C "$dir" log --oneline --no-decorate "$baseRef..HEAD" || true; echo ""; echo "--- diffstat (baseRef...HEAD) ---"; git -C "$dir" diff --stat "$baseRef...HEAD" || true; echo ""; echo "--- full diff (baseRef...HEAD) ---"; git -C "$dir" diff "$baseRef...HEAD" || true; echo ""; done'
    coderabbit: 'KIND="{{hs_kind}}"; if [ -z "$KIND" ] || [ "$KIND" = "parent" ]; then echo "Refusing evidence capture for hs_kind=parent. Run evidence on a track/component task."; exit 1; fi; TASK_STACK="{{stack}}"; TASK_STACK="${TASK_STACK%\"}"; TASK_STACK="${TASK_STACK#\"}"; ENV_STACK="${HAPPY_STACKS_STACK:?Run via: happys edison --stack=$TASK_STACK -- evidence capture <task-id>}"; if [ -z "$TASK_STACK" ]; then echo "Missing task stack (fill frontmatter: stack)"; exit 1; fi; if [ "$ENV_STACK" != "$TASK_STACK" ]; then echo "Stack mismatch: env=$ENV_STACK task=$TASK_STACK"; exit 1; fi; REMOTE_DEFAULT="${HAPPY_STACKS_STACK_REMOTE:-upstream}"; IFS="," read -r -a COMPS <<< "{{components_csv}}"; echo "=== coderabbit ==="; echo "task: {{task_id}}"; echo "stack: $TASK_STACK"; echo "stackRemote: ${REMOTE_DEFAULT}"; echo ""; fail=0; for comp in "${COMPS[@]}"; do comp="$(echo "$comp" | tr -d "[:space:]")"; [ -z "$comp" ] && continue; case "$comp" in happy) dir="$HAPPY_STACKS_COMPONENT_DIR_HAPPY" ;; happy-cli) dir="$HAPPY_STACKS_COMPONENT_DIR_HAPPY_CLI" ;; happy-server) dir="$HAPPY_STACKS_COMPONENT_DIR_HAPPY_SERVER" ;; happy-server-light) dir="$HAPPY_STACKS_COMPONENT_DIR_HAPPY_SERVER_LIGHT" ;; *) dir="" ;; esac; echo "============================================================================"; echo "component: $comp"; if [ -z "$dir" ]; then echo "ERROR: missing component dir env for $comp"; exit 1; fi; echo "dir: $dir"; remote="$REMOTE_DEFAULT"; if ! git -C "$dir" remote get-url "$remote" >/dev/null 2>&1; then if [ "$remote" = "origin" ] && git -C "$dir" remote get-url fork >/dev/null 2>&1; then remote="fork"; elif [ "$remote" = "fork" ] && git -C "$dir" remote get-url origin >/dev/null 2>&1; then remote="origin"; fi; fi; if ! git -C "$dir" remote get-url "$remote" >/dev/null 2>&1; then echo "ERROR: remote not found in $comp repo: $remote"; git -C "$dir" remote -v || true; exit 1; fi; headref="$(git -C "$dir" symbolic-ref -q "refs/remotes/$remote/HEAD" 2>/dev/null || true)"; if [ -n "$headref" ]; then defaultBranch="${headref##*/}"; else defaultBranch="$(git -C "$dir" remote show "$remote" 2>/dev/null | sed -n "s/^  HEAD branch: //p" | head -1)"; fi; if [ -z "$defaultBranch" ]; then defaultBranch="main"; fi; if ! git -C "$dir" show-ref --quiet "refs/remotes/$remote/$defaultBranch"; then echo "ERROR: cannot resolve base ref refs/remotes/$remote/$defaultBranch"; echo "Hint: ensure $remote has a HEAD/default branch configured."; exit 1; fi; baseRef="$remote/$defaultBranch"; echo "baseRef: $baseRef"; echo ""; echo "--- coderabbit review (all, base=$baseRef) ---"; tmp="$(mktemp)"; coderabbit review --plain --no-color --type all --base "$baseRef" --cwd "$dir" 2>&1 | tee "$tmp"; code="${PIPESTATUS[0]}"; if [ "$code" -ne 0 ]; then echo "ERROR: coderabbit exited non-zero (code=$code)"; fail=1; fi; if grep -Eiq "^[[:space:]]*Error:[[:space:]]|Git repository not found\\." "$tmp"; then echo "ERROR: coderabbit produced an error message (see output above)"; fail=1; fi; if grep -Eiq "^[[:space:]]*Type[[:space:]]*:[[:space:]]*(security_issue|critical_issue|bug)\\b" "$tmp"; then fail=1; fi; rm -f "$tmp"; echo ""; done; if [ "$fail" -ne 0 ]; then echo "Result: FAIL (blocking findings detected, or coderabbit failed)"; exit 1; fi; echo "Result: PASS (no blocking findings detected)"; exit 0'

  # Optional baseline multi-repo fingerprint inputs.
  # Happy Stacks wrappers (`happys edison --stack=...`) will override these at runtime to include
  # the stackâ€™s resolved component repo paths + the stack env file itself.
  fingerprint:
    git_roots:
      - "."
    extra_files: []
